(self.webpackChunkbabylonjs_typescript_webpack_simple_scene=self.webpackChunkbabylonjs_typescript_webpack_simple_scene||[]).push([[50],{8050:(e,t,i)=>{"use strict";i.r(t),i.d(t,{WavesCascade:()=>s});var n=i(1146),r=i(494),a=i(8220),s=function(){function e(e,t,i,s,p){this._engine=p,this._size=e,this._initialSpectrum=new r.InitialSpectrum(p,i,s,e,t),this._timeDependentSpectrum=new n.UJu("timeDependentSpectrumCS",this._engine,{computeSource:"[[group(0), binding(0)]] var H0Sampler : sampler;\r\n[[group(0), binding(1)]] var H0 : texture_2d<f32>;\r\n[[group(0), binding(2)]] var WavesDataSampler : sampler;\r\n[[group(0), binding(3)]] var WavesData : texture_2d<f32>;\r\n\r\n[[block]] struct Params {\r\n    Time : f32;\r\n};\r\n\r\n[[group(0), binding(4)]] var<uniform> params : Params;\r\n\r\n[[group(0), binding(5)]] var DxDz_DyDxz : texture_storage_2d<rgba32float, write>;\r\n[[group(0), binding(6)]] var DyxDyz_DxxDzz : texture_storage_2d<rgba32float, write>;\r\n\r\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\r\n}\r\n\r\n[[stage(compute), workgroup_size(8,8,1)]]\r\nfn calculateAmplitudes([[builtin(global_invocation_id)]] id : vec3<u32>)\r\n{\r\n    ignore(H0Sampler);\r\n    ignore(WavesDataSampler);\r\n\r\n    let iid = vec3<i32>(id);\r\n\tlet wave = textureLoad(WavesData, iid.xy, 0);\r\n\tlet phase = wave.w * params.Time;\r\n\tlet exponent = vec2<f32>(cos(phase), sin(phase));\r\n    let h0 = textureLoad(H0, iid.xy, 0);\r\n\tlet h = complexMult(h0.xy, exponent) + complexMult(h0.zw, vec2<f32>(exponent.x, -exponent.y));\r\n\tlet ih = vec2<f32>(-h.y, h.x);\r\n\t\r\n\tlet displacementX = ih * wave.x * wave.y;\r\n\tlet displacementY = h;\r\n\tlet displacementZ = ih * wave.z * wave.y;\r\n\t\t \r\n\tlet displacementX_dx = -h * wave.x * wave.x * wave.y;\r\n\tlet displacementY_dx = ih * wave.x;\r\n\tlet displacementZ_dx = -h * wave.x * wave.z * wave.y;\r\n\t\t \r\n\tlet displacementY_dz = ih * wave.z;\r\n\tlet displacementZ_dz = -h * wave.z * wave.z * wave.y;\r\n\t\r\n\ttextureStore(DxDz_DyDxz, iid.xy,   vec4<f32>(displacementX.x - displacementZ.y, displacementX.y + displacementZ.x, displacementY.x - displacementZ_dx.y, displacementY.y + displacementZ_dx.x));\r\n\ttextureStore(DyxDyz_DxxDzz, iid.xy, vec4<f32>(displacementY_dx.x - displacementY_dz.y, displacementY_dx.y + displacementY_dz.x, displacementX_dx.x - displacementZ_dz.y, displacementX_dx.y + displacementZ_dz.x));\r\n}\r\n"},{bindingsMapping:{H0:{group:0,binding:1},WavesData:{group:0,binding:3},params:{group:0,binding:4},DxDz_DyDxz:{group:0,binding:5},DyxDyz_DxxDzz:{group:0,binding:6}},entryPoint:"calculateAmplitudes"}),this._DxDz_DyDxz=a.ComputeHelper.CreateStorageTexture("DxDz_DyDxz",this._engine,this._size,this._size,n.gTE.TEXTUREFORMAT_RGBA),this._DyxDyz_DxxDzz=a.ComputeHelper.CreateStorageTexture("DyxDyz_DxxDzz",this._engine,this._size,this._size,n.gTE.TEXTUREFORMAT_RGBA),this._params=new n.Ms4(this._engine),this._params.addUniform("Time",1),this._timeDependentSpectrum.setTexture("H0",this._initialSpectrum.initialSpectrum),this._timeDependentSpectrum.setTexture("WavesData",this._initialSpectrum.wavesData),this._timeDependentSpectrum.setUniformBuffer("params",this._params),this._timeDependentSpectrum.setStorageTexture("DxDz_DyDxz",this._DxDz_DyDxz),this._timeDependentSpectrum.setStorageTexture("DyxDyz_DxxDzz",this._DyxDyz_DxxDzz),i.setTexture(s+3,"DxDz / DyDxz",this._DxDz_DyDxz,1e3),i.setTexture(s+4,"DyxDyz / DxxDzz",this._DyxDyz_DxxDzz,1e3)}return e.prototype.calculateInitials=function(e,t,i,n){this._initialSpectrum.generate(e,t,i,n)},e.prototype.calculateWavesAtTime=function(e){this._params.updateFloat("Time",e),this._params.update(),a.ComputeHelper.Dispatch(this._timeDependentSpectrum,this._size,this._size,1)},e.prototype.dispose=function(){this._initialSpectrum.dispose(),this._DxDz_DyDxz.dispose(),this._DyxDyz_DxxDzz.dispose()},e}()}}]);
//# sourceMappingURL=50.babylonBundle.js.map