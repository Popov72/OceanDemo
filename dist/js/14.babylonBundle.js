(self.webpackChunkbabylonjs_typescript_webpack_simple_scene=self.webpackChunkbabylonjs_typescript_webpack_simple_scene||[]).push([[14],{7014:(e,r,t)=>{"use strict";t.r(r),t.d(r,{ComputeHelper:()=>n});var a=t(1465),n=function(){function e(){}return e.GetThreadGroupSizes=function(e,r){var t=new RegExp("workgroup_size\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)]]\\s*fn\\s+"+r+"\\s*\\(","g").exec(e);return t?new a.Pa4(parseInt(t[1]),parseInt(t[2]),parseInt(t[3])):new a.Pa4(1,1,1)},e.CreateStorageTexture=function(e,r,t,n,i,u,o,p,s,d){var g,c;void 0===i&&(i=a.gTE.TEXTUREFORMAT_RGBA),void 0===u&&(u=a.gTE.TEXTURETYPE_FLOAT),void 0===o&&(o=a.gTE.TEXTURE_NEAREST_SAMPLINGMODE),void 0===p&&(p=!1),void 0===s&&(s=a.gTE.TEXTURE_WRAP_ADDRESSMODE),void 0===d&&(d=null);var f=d?d.getSize():{width:0,height:0},l=f.width,_=f.height,m=d?null!==(g=d.getInternalTexture().type)&&void 0!==g?g:-1:-2,x=d?null!==(c=d.getInternalTexture().format)&&void 0!==c?c:-1:-2;return-1===m&&(m=a.gTE.TEXTURETYPE_UNSIGNED_BYTE),-1===x&&(x=a.gTE.TEXTUREFORMAT_RGBA),d&&l===t&&_===n&&u===m&&i===x||((d=new a.lMF(null,t,n,i,r,p,!1,o,u,a.gTE.TEXTURE_CREATIONFLAG_STORAGE)).name=e),d.wrapU=s,d.wrapV=s,d.updateSamplingMode(o),d},e.CopyTexture=function(r,t,n){var i,u,o=r.getInternalTexture().format===a.gTE.TEXTUREFORMAT_RG?2:4;if(!e._copyTexture4CS&&4===o||!e._copyTexture2CS&&2===o){var p=null!==(u=null===(i=r.getScene())||void 0===i?void 0:i.getEngine())&&void 0!==u?u:n,s=new a.UJu("copyTexture"+o+"Compute",p,{computeSource:4===o?e._copyTexture4ComputeShader:e._copyTexture2ComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),d=new a.Ms4(p);d.addUniform("width",1),d.addUniform("height",1),s.setUniformBuffer("params",d),4===o?(e._copyTexture4CS=s,e._copyTexture4Params=d):(e._copyTexture2CS=s,e._copyTexture2Params=d)}var g=4===o?e._copyTexture4CS:e._copyTexture2CS,c=4===o?e._copyTexture4Params:e._copyTexture2Params;g.setTexture("src",r,!1),g.setStorageTexture("dest",t);var f=r.getSize(),l=f.width,_=f.height;c.updateInt("width",l),c.updateInt("height",_),c.update(),e.Dispatch(g,l,_,1)},e.CopyBufferToTexture=function(r,t){if(!e._copyBufferTextureCS){var n=t.getScene().getEngine(),i=new a.UJu("copyBufferTextureCompute",n,{computeSource:e._copyBufferTextureComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),u=new a.Ms4(n);u.addUniform("width",1),u.addUniform("height",1),i.setUniformBuffer("params",u),e._copyBufferTextureCS=i,e._copyBufferTextureParams=u}e._copyBufferTextureCS.setStorageBuffer("src",r),e._copyBufferTextureCS.setStorageTexture("dest",t);var o=t.getSize(),p=o.width,s=o.height;e._copyBufferTextureParams.updateInt("width",p),e._copyBufferTextureParams.updateInt("height",s),e._copyBufferTextureParams.update(),e.Dispatch(e._copyBufferTextureCS,p,s,1)},e.CopyTextureToBuffer=function(r,t){if(!e._copyTextureBufferCS){var n=r.getScene().getEngine(),i=new a.UJu("copyTextureBufferCompute",n,{computeSource:e._copyTextureBufferComputeShader},{bindingsMapping:{src:{group:0,binding:0},dest:{group:0,binding:1},params:{group:0,binding:2}}}),u=new a.Ms4(n);u.addUniform("width",1),u.addUniform("height",1),i.setUniformBuffer("params",u),e._copyTextureBufferCS=i,e._copyTextureBufferParams=u}e._copyTextureBufferCS.setTexture("src",r,!1),e._copyTextureBufferCS.setStorageBuffer("dest",t);var o=r.getSize(),p=o.width,s=o.height;e._copyTextureBufferParams.updateInt("width",p),e._copyTextureBufferParams.updateInt("height",s),e._copyTextureBufferParams.update(),e.Dispatch(e._copyTextureBufferCS,p,s,1)},e.ClearTexture=function(r,t){if(!e._clearTextureCS){var n=r.getScene().getEngine(),i=new a.UJu("clearTextureCompute",n,{computeSource:e._clearTextureComputeShader},{bindingsMapping:{tbuf:{group:0,binding:0},params:{group:0,binding:1}}}),u=new a.Ms4(n);u.addUniform("color",4),u.addUniform("width",1),u.addUniform("height",1),i.setUniformBuffer("params",u),e._clearTextureCS=i,e._clearTextureParams=u}e._clearTextureCS.setStorageTexture("tbuf",r);var o=r.getSize(),p=o.width,s=o.height;e._clearTextureParams.updateDirectColor4("color",t),e._clearTextureParams.updateInt("width",p),e._clearTextureParams.updateInt("height",s),e._clearTextureParams.update(),e.Dispatch(e._clearTextureCS,p,s,1)},e.Dispatch=function(r,t,a,n){var i;void 0===a&&(a=1),void 0===n&&(n=1),r.threadGroupSizes||(r.threadGroupSizes=e.GetThreadGroupSizes(r.shaderPath.computeSource,null!==(i=r.options.entryPoint)&&void 0!==i?i:"main"));var u=r.threadGroupSizes,o=Math.ceil(t/u.x),p=Math.ceil(a/u.y),s=Math.ceil(n/u.z);r.dispatch(o,p,s)},e._clearTextureComputeShader="\n        [[group(0), binding(0)]] var tbuf : texture_storage_2d<rgba32float, write>;\n\n        [[block]] struct Params {\n            color : vec4<f32>;\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(1)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            textureStore(tbuf, vec2<i32>(global_id.xy), params.color);\n        }\n    ",e._copyTexture4ComputeShader="\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba32float, write>;\n        [[group(0), binding(1)]] var src : texture_2d<f32>;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTexture2ComputeShader="\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rg32float, write>;\n        [[group(0), binding(1)]] var src : texture_2d<f32>;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyBufferTextureComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba32float, write>;\n        [[group(0), binding(1)]] var<storage, read> src : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = vec4<f32>(src.elements[offset], src.elements[offset + 1u], src.elements[offset + 2u], src.elements[offset + 3u]);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTextureBufferComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var src : texture_2d<f32>;\n        [[group(0), binding(1)]] var<storage, write> dest : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            dest.elements[offset] = pix.r;\n            dest.elements[offset + 1u] = pix.g;\n            dest.elements[offset + 2u] = pix.b;\n            dest.elements[offset + 3u] = pix.a;\n        }\n    ",e}()}}]);
//# sourceMappingURL=14.babylonBundle.js.map