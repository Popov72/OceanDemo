"use strict";(self.webpackChunkbabylonjs_ocean_demo=self.webpackChunkbabylonjs_ocean_demo||[]).push([[292],{4292:(t,e,s)=>{s.r(e),s.d(e,{Buoyancy:()=>a});var o=s(3353);class a{constructor(t,e=5,s=1){this.enabled=!0,this._size=t,this._displacementMap=null,this._lengthScale=0,this._numSteps=e,this._attenuation=s,this._meshes=[]}setWaterHeightMap(t,e){this._displacementMap=t,this._lengthScale=e}addMesh(t,e,s=0,a=0){this._meshes.push({mesh:t,frame:e,yOffset:s,spaceCoordinates:a,initQuaternion:t.rotationQuaternion.clone(),curStep:0,curQuaternion:new o.Quaternion,stepQuaternion:new o.Quaternion})}set size(t){this._size=t}get attenuation(){return this._attenuation}set attenuation(t){this._attenuation=t}get numSteps(){return this._numSteps}set numSteps(t){this._numSteps=t}update(){if(this.enabled)for(let t=0;t<this._meshes.length;++t)this._updateMesh(this._meshes[t])}getWaterHeight(t){const e=o.TmpVectors.Vector3[0];return this._getWaterDisplacement(t,e),t.subtractToRef(e,e),this._getWaterDisplacement(t,e),t.subtractToRef(e,e),this._getWaterDisplacement(t,e),t.subtractToRef(e,e),this._getWaterDisplacement(t,e),e.y}_updateMesh(t){const e=o.TmpVectors.Vector3[5],s=o.TmpVectors.Vector3[6],a=o.TmpVectors.Vector3[7],r=o.TmpVectors.Vector3[8],i=o.TmpVectors.Vector3[9],n=o.TmpVectors.Vector3[10],c=o.TmpVectors.Vector3[11],h=o.TmpVectors.Vector3[12],{mesh:l,frame:p,yOffset:u,spaceCoordinates:m,initQuaternion:_,curQuaternion:T,stepQuaternion:f,curStep:d}=t;o.Vector3.TransformCoordinatesToRef(p.v1,l.getWorldMatrix(),e);const V=this.getWaterHeight(e);if(l.position.y=V+u,p.v2&&p.v3){if(d<this._numSteps)return t.curStep++,T.multiplyToRef(f,T),void _.multiplyToRef(T,l.rotationQuaternion);o.Vector3.TransformCoordinatesToRef(p.v2,l.getWorldMatrix(),s),s.subtractToRef(e,c),c.normalize(),o.Vector3.TransformCoordinatesToRef(p.v3,l.getWorldMatrix(),a),a.subtractToRef(e,h),h.normalize(),e.y=V,r.copyFrom(s),r.y=this.getWaterHeight(s),r.subtractToRef(e,r),r.normalize(),i.copyFrom(a),i.y=this.getWaterHeight(a),i.subtractToRef(e,i),i.normalize(),o.Vector3.CrossToRef(i,r,n),o.Vector3.CrossToRef(r,n,i),i.normalize();let u=Math.acos(o.Scalar.Clamp(o.Vector3.Dot(c,r),0,1))*this._attenuation,g=Math.acos(o.Scalar.Clamp(o.Vector3.Dot(h,i),0,1))*this._attenuation;switch(m){case 0:r.y>c.y&&(u=-u),i.y>h.y&&(g=-g),o.Quaternion.FromEulerAnglesToRef(u/this._numSteps,g/this._numSteps,0,t.stepQuaternion);break;case 1:r.y>c.y&&(u=-u),i.y<h.y&&(g=-g),o.Quaternion.FromEulerAnglesToRef(u/this._numSteps,0,g/this._numSteps,t.stepQuaternion);break;case 2:r.y>c.y&&(u=-u),i.y>h.y&&(g=-g),o.Quaternion.FromEulerAnglesToRef(u/this._numSteps,0,g/this._numSteps,t.stepQuaternion)}t.curStep=0}}_getWaterDisplacement(t,e){if(!this._displacementMap)return void e.set(t.x,t.y,t.z);const s=this._size-1,a=t.x/this._lengthScale*this._size,r=t.z/this._lengthScale*this._size,i=o.TmpVectors.Vector3[1],n=o.TmpVectors.Vector3[2],c=o.TmpVectors.Vector3[3],h=o.TmpVectors.Vector3[4];let l=Math.floor(a),p=Math.floor(r);const u=a-l,m=r-p;l&=s,p&=s,this._getDisplacement(l,p,i),this._getDisplacement(l+1&s,p,n),n.subtractToRef(i,c).scaleToRef(u,c).addToRef(i,c),this._getDisplacement(l,p+1&s,i),this._getDisplacement(l+1&s,p+1&s,n),n.subtractToRef(i,h).scaleToRef(u,h).addToRef(i,h),h.subtractToRef(c,e).scaleToRef(m,e).addToRef(c,e)}_getDisplacement(t,e,s){this._displacementMap&&(s.x=o.TextureTools.FromHalfFloat(this._displacementMap[e*this._size*4+4*t+0]),s.y=o.TextureTools.FromHalfFloat(this._displacementMap[e*this._size*4+4*t+1]),s.z=o.TextureTools.FromHalfFloat(this._displacementMap[e*this._size*4+4*t+2]))}}}}]);
//# sourceMappingURL=292.1ab9f7e21c2889afadb4.js.map