(self.webpackChunkbabylonjs_ocean_demo=self.webpackChunkbabylonjs_ocean_demo||[]).push([[14],{7014:(e,r,t)=>{"use strict";t.r(r),t.d(r,{ComputeHelper:()=>a});var n=t(2264),a=function(){function e(){}return e.GetThreadGroupSizes=function(e,r){var t=new RegExp("workgroup_size\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)]]\\s*fn\\s+"+r+"\\s*\\(","g").exec(e);return t?new n.Vector3(parseInt(t[1]),parseInt(t[2]),parseInt(t[3])):new n.Vector3(1,1,1)},e.CreateStorageTexture=function(e,r,t,a,o,i,u,s,d,p){var g,f;void 0===o&&(o=n.Constants.TEXTUREFORMAT_RGBA),void 0===i&&(i=n.Constants.TEXTURETYPE_FLOAT),void 0===u&&(u=n.Constants.TEXTURE_NEAREST_SAMPLINGMODE),void 0===s&&(s=!1),void 0===d&&(d=n.Constants.TEXTURE_WRAP_ADDRESSMODE),void 0===p&&(p=null);var c=p?p.getSize():{width:0,height:0},l=c.width,m=c.height,_=p?null!==(g=p.getInternalTexture().type)&&void 0!==g?g:-1:-2,h=p?null!==(f=p.getInternalTexture().format)&&void 0!==f?f:-1:-2;return-1===_&&(_=n.Constants.TEXTURETYPE_UNSIGNED_BYTE),-1===h&&(h=n.Constants.TEXTUREFORMAT_RGBA),p&&l===t&&m===a&&i===_&&o===h||((p=new n.RawTexture(null,t,a,o,r,s,!1,u,i,n.Constants.TEXTURE_CREATIONFLAG_STORAGE)).name=e),p.wrapU=d,p.wrapV=d,p.updateSamplingMode(u),p},e.CopyTexture=function(r,t,a){var o,i,u=r.getInternalTexture().format===n.Constants.TEXTUREFORMAT_RG?2:4;if(!e._copyTexture4CS&&4===u||!e._copyTexture2CS&&2===u){var s=null!==(i=null===(o=r.getScene())||void 0===o?void 0:o.getEngine())&&void 0!==i?i:a,d=new n.ComputeShader("copyTexture"+u+"Compute",s,{computeSource:4===u?e._copyTexture4ComputeShader:e._copyTexture2ComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),p=new n.UniformBuffer(s);p.addUniform("width",1),p.addUniform("height",1),d.setUniformBuffer("params",p),4===u?(e._copyTexture4CS=d,e._copyTexture4Params=p):(e._copyTexture2CS=d,e._copyTexture2Params=p)}var g=4===u?e._copyTexture4CS:e._copyTexture2CS,f=4===u?e._copyTexture4Params:e._copyTexture2Params;g.setTexture("src",r,!1),g.setStorageTexture("dest",t);var c=r.getSize(),l=c.width,m=c.height;f.updateInt("width",l),f.updateInt("height",m),f.update(),e.Dispatch(g,l,m,1)},e.CopyBufferToTexture=function(r,t){if(!e._copyBufferTextureCS){var a=t.getScene().getEngine(),o=new n.ComputeShader("copyBufferTextureCompute",a,{computeSource:e._copyBufferTextureComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),i=new n.UniformBuffer(a);i.addUniform("width",1),i.addUniform("height",1),o.setUniformBuffer("params",i),e._copyBufferTextureCS=o,e._copyBufferTextureParams=i}e._copyBufferTextureCS.setStorageBuffer("src",r),e._copyBufferTextureCS.setStorageTexture("dest",t);var u=t.getSize(),s=u.width,d=u.height;e._copyBufferTextureParams.updateInt("width",s),e._copyBufferTextureParams.updateInt("height",d),e._copyBufferTextureParams.update(),e.Dispatch(e._copyBufferTextureCS,s,d,1)},e.CopyTextureToBuffer=function(r,t){if(!e._copyTextureBufferCS){var a=r.getScene().getEngine(),o=new n.ComputeShader("copyTextureBufferCompute",a,{computeSource:e._copyTextureBufferComputeShader},{bindingsMapping:{src:{group:0,binding:0},dest:{group:0,binding:1},params:{group:0,binding:2}}}),i=new n.UniformBuffer(a);i.addUniform("width",1),i.addUniform("height",1),o.setUniformBuffer("params",i),e._copyTextureBufferCS=o,e._copyTextureBufferParams=i}e._copyTextureBufferCS.setTexture("src",r,!1),e._copyTextureBufferCS.setStorageBuffer("dest",t);var u=r.getSize(),s=u.width,d=u.height;e._copyTextureBufferParams.updateInt("width",s),e._copyTextureBufferParams.updateInt("height",d),e._copyTextureBufferParams.update(),e.Dispatch(e._copyTextureBufferCS,s,d,1)},e.ClearTexture=function(r,t){if(!e._clearTextureCS){var a=r.getScene().getEngine(),o=new n.ComputeShader("clearTextureCompute",a,{computeSource:e._clearTextureComputeShader},{bindingsMapping:{tbuf:{group:0,binding:0},params:{group:0,binding:1}}}),i=new n.UniformBuffer(a);i.addUniform("color",4),i.addUniform("width",1),i.addUniform("height",1),o.setUniformBuffer("params",i),e._clearTextureCS=o,e._clearTextureParams=i}e._clearTextureCS.setStorageTexture("tbuf",r);var u=r.getSize(),s=u.width,d=u.height;e._clearTextureParams.updateDirectColor4("color",t),e._clearTextureParams.updateInt("width",s),e._clearTextureParams.updateInt("height",d),e._clearTextureParams.update(),e.Dispatch(e._clearTextureCS,s,d,1)},e.Dispatch=function(r,t,n,a){var o;void 0===n&&(n=1),void 0===a&&(a=1),r.threadGroupSizes||(r.threadGroupSizes=e.GetThreadGroupSizes(r.shaderPath.computeSource,null!==(o=r.options.entryPoint)&&void 0!==o?o:"main"));var i=r.threadGroupSizes,u=Math.ceil(t/i.x),s=Math.ceil(n/i.y),d=Math.ceil(a/i.z);r.dispatch(u,s,d)},e._clearTextureComputeShader="\n        [[group(0), binding(0)]] var tbuf : texture_storage_2d<rgba32float, write>;\n\n        [[block]] struct Params {\n            color : vec4<f32>;\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(1)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            textureStore(tbuf, vec2<i32>(global_id.xy), params.color);\n        }\n    ",e._copyTexture4ComputeShader="\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba32float, write>;\n        [[group(0), binding(1)]] var src : texture_2d<f32>;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTexture2ComputeShader="\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rg32float, write>;\n        [[group(0), binding(1)]] var src : texture_2d<f32>;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyBufferTextureComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba32float, write>;\n        [[group(0), binding(1)]] var<storage, read> src : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = vec4<f32>(src.elements[offset], src.elements[offset + 1u], src.elements[offset + 2u], src.elements[offset + 3u]);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTextureBufferComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var src : texture_2d<f32>;\n        [[group(0), binding(1)]] var<storage, write> dest : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            dest.elements[offset] = pix.r;\n            dest.elements[offset + 1u] = pix.g;\n            dest.elements[offset + 2u] = pix.b;\n            dest.elements[offset + 3u] = pix.a;\n        }\n    ",e}()}}]);
//# sourceMappingURL=14.babylonBundle.js.map