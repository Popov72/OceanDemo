(self.webpackChunkbabylonjs_typescript_webpack_simple_scene=self.webpackChunkbabylonjs_typescript_webpack_simple_scene||[]).push([[220],{8220:(e,r,t)=>{"use strict";t.r(r),t.d(r,{ComputeHelper:()=>n});var a=t(1146),n=function(){function e(){}return e.GetThreadGroupSizes=function(e,r){var t=new RegExp("workgroup_size\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)]]\\s*fn\\s+"+r+"\\s*\\(","g").exec(e);return t?new a.Pa4(parseInt(t[1]),parseInt(t[2]),parseInt(t[3])):new a.Pa4(1,1,1)},e.CreateStorageTexture=function(e,r,t,n,i,u,o,s,p,d){var g,c;void 0===i&&(i=a.gTE.TEXTUREFORMAT_RGBA),void 0===u&&(u=a.gTE.TEXTURETYPE_FLOAT),void 0===o&&(o=a.gTE.TEXTURE_NEAREST_SAMPLINGMODE),void 0===s&&(s=!1),void 0===p&&(p=a.gTE.TEXTURE_WRAP_ADDRESSMODE),void 0===d&&(d=null);var f=d?d.getSize():{width:0,height:0},l=f.width,m=f.height,_=d?null!==(g=d.getInternalTexture().type)&&void 0!==g?g:-1:-2,h=d?null!==(c=d.getInternalTexture().format)&&void 0!==c?c:-1:-2;return-1===_&&(_=a.gTE.TEXTURETYPE_UNSIGNED_BYTE),-1===h&&(h=a.gTE.TEXTUREFORMAT_RGBA),d&&l===t&&m===n&&u===_&&i===h||((d=new a.lMF(null,t,n,i,r,s,!1,o,u,a.gTE.TEXTURE_CREATIONFLAG_STORAGE)).name=e),d.wrapU=p,d.wrapV=p,d.updateSamplingMode(o),d},e.CopyTexture=function(r,t){if(!e._copyTextureCS){var n=r.getScene().getEngine(),i=new a.UJu("copyTextureCompute",n,{computeSource:e._copyTextureComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),u=new a.Ms4(n);u.addUniform("width",1),u.addUniform("height",1),i.setUniformBuffer("params",u),e._copyTextureCS=i,e._copyTextureParams=u}e._copyTextureCS.setStorageTexture("src",r),e._copyTextureCS.setStorageTexture("dest",t);var o=r.getSize(),s=o.width,p=o.height;e._copyTextureParams.updateInt("width",s),e._copyTextureParams.updateInt("height",p),e._copyTextureParams.update(),e.Dispatch(e._copyTextureCS,s,p,1)},e.CopyBufferToTexture=function(r,t){if(!e._copyBufferTextureCS){var n=t.getScene().getEngine(),i=new a.UJu("copyBufferTextureCompute",n,{computeSource:e._copyBufferTextureComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),u=new a.Ms4(n);u.addUniform("width",1),u.addUniform("height",1),i.setUniformBuffer("params",u),e._copyBufferTextureCS=i,e._copyBufferTextureParams=u}e._copyBufferTextureCS.setStorageBuffer("src",r),e._copyBufferTextureCS.setStorageTexture("dest",t);var o=t.getSize(),s=o.width,p=o.height;e._copyBufferTextureParams.updateInt("width",s),e._copyBufferTextureParams.updateInt("height",p),e._copyBufferTextureParams.update(),e.Dispatch(e._copyBufferTextureCS,s,p,1)},e.CopyTextureToBuffer=function(r,t){if(!e._copyTextureBufferCS){var n=r.getScene().getEngine(),i=new a.UJu("copyTextureBufferCompute",n,{computeSource:e._copyTextureBufferComputeShader},{bindingsMapping:{src:{group:0,binding:0},dest:{group:0,binding:1},params:{group:0,binding:2}}}),u=new a.Ms4(n);u.addUniform("width",1),u.addUniform("height",1),i.setUniformBuffer("params",u),e._copyTextureBufferCS=i,e._copyTextureBufferParams=u}e._copyTextureBufferCS.setStorageTexture("src",r),e._copyTextureBufferCS.setStorageBuffer("dest",t);var o=r.getSize(),s=o.width,p=o.height;e._copyTextureBufferParams.updateInt("width",s),e._copyTextureBufferParams.updateInt("height",p),e._copyTextureBufferParams.update(),e.Dispatch(e._copyTextureBufferCS,s,p,1)},e.ClearTexture=function(r,t){if(!e._clearTextureCS){var n=r.getScene().getEngine(),i=new a.UJu("clearTextureCompute",n,{computeSource:e._clearTextureComputeShader},{bindingsMapping:{tbuf:{group:0,binding:0},params:{group:0,binding:1}}}),u=new a.Ms4(n);u.addUniform("color",4),u.addUniform("width",1),u.addUniform("height",1),i.setUniformBuffer("params",u),e._clearTextureCS=i,e._clearTextureParams=u}e._clearTextureCS.setStorageTexture("tbuf",r);var o=r.getSize(),s=o.width,p=o.height;e._clearTextureParams.updateDirectColor4("color",t),e._clearTextureParams.updateInt("width",s),e._clearTextureParams.updateInt("height",p),e._clearTextureParams.update(),e.Dispatch(e._clearTextureCS,s,p,1)},e.Dispatch=function(r,t,a,n){var i;void 0===a&&(a=1),void 0===n&&(n=1),r.threadGroupSizes||(r.threadGroupSizes=e.GetThreadGroupSizes(r.shaderPath.computeSource,null!==(i=r.options.entryPoint)&&void 0!==i?i:"main"));var u=r.threadGroupSizes,o=Math.ceil(t/u.x),s=Math.ceil(a/u.y),p=Math.ceil(n/u.z);r.dispatch(o,s,p)},e._clearTextureComputeShader="\n        [[group(0), binding(0)]] var tbuf : texture_storage_2d<rgba16float, write>;\n\n        [[block]] struct Params {\n            color : vec4<f32>;\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(1)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            textureStore(tbuf, vec2<i32>(global_id.xy), params.color);\n        }\n    ",e._copyTextureComputeShader="\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba16float, write>;\n        [[group(0), binding(1)]] var src : texture_storage_2d<rgba16float, read>;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy));\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyBufferTextureComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba16float, write>;\n        [[group(0), binding(1)]] var<storage, read> src : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = vec4<f32>(src.elements[offset], src.elements[offset + 1u], src.elements[offset + 2u], src.elements[offset + 3u]);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTextureBufferComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var src : texture_storage_2d<rgba16float, read>;\n        [[group(0), binding(1)]] var<storage, write> dest : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy));\n            dest.elements[offset] = pix.r;\n            dest.elements[offset + 1u] = pix.g;\n            dest.elements[offset + 2u] = pix.b;\n            dest.elements[offset + 3u] = pix.a;\n        }\n    ",e}()}}]);
//# sourceMappingURL=220.babylonBundle.js.map