(self.webpackChunkbabylonjs_ocean_demo=self.webpackChunkbabylonjs_ocean_demo||[]).push([[160,14],{7160:(e,t,r)=>{"use strict";r.r(t),r.d(t,{FFT:()=>a});var n=r(7976),i=r(7014),a=function(){function e(e,t,r,a,u){this._engine=e,this._rttDebug=r,this._debugFirstIndex=a,this._size=u,this._horizontalStepIFFT=[],this._verticalStepIFFT=[],this._permute=null;var o=new n.ComputeShader("computeTwiddleFactors",this._engine,{computeSource:"let PI: f32 = 3.1415926;\r\n\r\n@group(0) @binding(0) var PrecomputeBuffer : texture_storage_2d<rgba32float, write>;\r\n\r\nstruct Params {\r\n    Step : i32;\r\n    Size : i32;\r\n};\r\n\r\n@group(0) @binding(1) var<uniform> params : Params;\r\n\r\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\r\n}\r\n\r\nfn complexExp(a: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(cos(a.y), sin(a.y)) * exp(a.x);\r\n}\r\n\r\n@stage(compute) @workgroup_size(1,8,1)\r\nfn precomputeTwiddleFactorsAndInputIndices(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n\tlet b = params.Size >> (id.x + 1u);\r\n\tlet mult = 2.0 * PI * vec2<f32>(0.0, -1.0) / f32(params.Size);\r\n\tlet i = (2 * b * (iid.y / b) + (iid.y % b)) % params.Size;\r\n\tlet twiddle = complexExp(mult * vec2<f32>(f32((iid.y / b) * b)));\r\n\t\r\n    textureStore(PrecomputeBuffer, iid.xy, vec4<f32>(twiddle.x, twiddle.y, f32(i), f32(i + b)));\r\n\ttextureStore(PrecomputeBuffer, vec2<i32>(iid.x, iid.y + params.Size / 2), vec4<f32>(-twiddle.x, -twiddle.y, f32(i), f32(i + b)));\r\n}\r\n"},{bindingsMapping:{PrecomputeBuffer:{group:0,binding:0},params:{group:0,binding:1}},entryPoint:"precomputeTwiddleFactorsAndInputIndices"}),p=0|Math.log2(u);this._precomputedData=i.ComputeHelper.CreateStorageTexture("precomputeTwiddle",this._engine,p,this._size,n.Constants.TEXTUREFORMAT_RGBA),this._rttDebug.setTexture(this._debugFirstIndex,"precomputeTwiddle",this._precomputedData),this._params=new n.UniformBuffer(this._engine),this._params.addUniform("Step",1),this._params.addUniform("Size",1),o.setStorageTexture("PrecomputeBuffer",this._precomputedData),o.setUniformBuffer("params",this._params),this._params.updateInt("Size",this._size),this._params.update(),i.ComputeHelper.Dispatch(o,p,u/2,1),this._createComputeShaders()}return e.prototype.IFFT2D=function(e,t){for(var r=0|Math.log2(this._size),n=!1,a=0;a<r;++a)n=!n,this._params.updateInt("Step",a),this._params.update(),this._horizontalStepIFFT[0].setTexture("InputBuffer",n?e:t,!1),this._horizontalStepIFFT[0].setStorageTexture("OutputBuffer",n?t:e),i.ComputeHelper.Dispatch(this._horizontalStepIFFT[0],this._size,this._size,1);for(a=0;a<r;++a)n=!n,this._params.updateInt("Step",a),this._params.update(),this._verticalStepIFFT[0].setTexture("InputBuffer",n?e:t,!1),this._verticalStepIFFT[0].setStorageTexture("OutputBuffer",n?t:e),i.ComputeHelper.Dispatch(this._verticalStepIFFT[0],this._size,this._size,1);n&&i.ComputeHelper.CopyTexture(t,e,this._engine),this._permute.setTexture("InputBuffer",e,!1),this._permute.setStorageTexture("OutputBuffer",t),i.ComputeHelper.Dispatch(this._permute,this._size,this._size,1),i.ComputeHelper.CopyTexture(t,e,this._engine)},e.prototype.dispose=function(){this._precomputedData.dispose(),this._params.dispose()},e.prototype._createComputeShaders=function(){for(var e=0;e<2;++e)this._horizontalStepIFFT[e]=new n.ComputeShader("horizontalStepIFFT",this._engine,{computeSource:"struct Params {\r\n    Step : i32;\r\n    Size : i32;\r\n};\r\n\r\n@group(0) @binding(1) var<uniform> params : Params;\r\n\r\n@group(0) @binding(3) var PrecomputedData : texture_2d<f32>;\r\n\r\n@group(0) @binding(5) var InputBuffer : texture_2d<f32>;\r\n@group(0) @binding(6) var OutputBuffer : texture_storage_2d<rg32float, write>;\r\n\r\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\r\n}\r\n\r\n@stage(compute) @workgroup_size(8,8,1)\r\nfn horizontalStepInverseFFT(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n    let data = textureLoad(PrecomputedData, vec2<i32>(params.Step, iid.x), 0);\r\n\tlet inputsIndices = vec2<i32>(data.ba);\r\n\r\n    let input0 = textureLoad(InputBuffer, vec2<i32>(inputsIndices.x, iid.y), 0);\r\n    let input1 = textureLoad(InputBuffer, vec2<i32>(inputsIndices.y, iid.y), 0);\r\n\r\n    textureStore(OutputBuffer, iid.xy, vec4<f32>(\r\n        input0.xy + complexMult(vec2<f32>(data.r, -data.g), input1.xy), 0., 0.\r\n    ));\r\n}\r\n"},{bindingsMapping:{params:{group:0,binding:1},PrecomputedData:{group:0,binding:3},InputBuffer:{group:0,binding:5},OutputBuffer:{group:0,binding:6}},entryPoint:"horizontalStepInverseFFT"}),this._horizontalStepIFFT[e].setUniformBuffer("params",this._params),this._horizontalStepIFFT[e].setTexture("PrecomputedData",this._precomputedData,!1),this._verticalStepIFFT[e]=new n.ComputeShader("verticalStepIFFT",this._engine,{computeSource:"struct Params {\r\n    Step : i32;\r\n    Size : i32;\r\n};\r\n\r\n@group(0) @binding(1) var<uniform> params : Params;\r\n\r\n@group(0) @binding(3) var PrecomputedData : texture_2d<f32>;\r\n\r\n@group(0) @binding(5) var InputBuffer : texture_2d<f32>;\r\n@group(0) @binding(6) var OutputBuffer : texture_storage_2d<rg32float, write>;\r\n\r\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\r\n}\r\n\r\n@stage(compute) @workgroup_size(8,8,1)\r\nfn verticalStepInverseFFT(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n    let data = textureLoad(PrecomputedData, vec2<i32>(params.Step, iid.y), 0);\r\n\tlet inputsIndices = vec2<i32>(data.ba);\r\n\r\n    let input0 = textureLoad(InputBuffer, vec2<i32>(iid.x, inputsIndices.x), 0);\r\n    let input1 = textureLoad(InputBuffer, vec2<i32>(iid.x, inputsIndices.y), 0);\r\n\r\n    textureStore(OutputBuffer, iid.xy, vec4<f32>(\r\n        input0.xy + complexMult(vec2<f32>(data.r, -data.g), input1.xy), 0., 0.\r\n    ));\r\n}\r\n"},{bindingsMapping:{params:{group:0,binding:1},PrecomputedData:{group:0,binding:3},InputBuffer:{group:0,binding:5},OutputBuffer:{group:0,binding:6}},entryPoint:"verticalStepInverseFFT"}),this._verticalStepIFFT[e].setUniformBuffer("params",this._params),this._verticalStepIFFT[e].setTexture("PrecomputedData",this._precomputedData,!1);this._permute=new n.ComputeShader("permute",this._engine,{computeSource:"@group(0) @binding(5) var InputBuffer : texture_2d<f32>;\r\n@group(0) @binding(6) var OutputBuffer : texture_storage_2d<rg32float, write>;\r\n\r\n@stage(compute) @workgroup_size(8,8,1)\r\nfn permute(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n    let input = textureLoad(InputBuffer, iid.xy, 0);\r\n\r\n    textureStore(OutputBuffer, iid.xy, input * (1.0 - 2.0 * f32((iid.x + iid.y) % 2)));\r\n}\r\n"},{bindingsMapping:{InputBuffer:{group:0,binding:5},OutputBuffer:{group:0,binding:6}},entryPoint:"permute"})},e}()},7014:(e,t,r)=>{"use strict";r.r(t),r.d(t,{ComputeHelper:()=>i});var n=r(7976),i=function(){function e(){}return e.GetThreadGroupSizes=function(e,t){var r=new RegExp("workgroup_size\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*fn\\s+"+t+"\\s*\\(","g").exec(e);return r?new n.Vector3(parseInt(r[1]),parseInt(r[2]),parseInt(r[3])):new n.Vector3(1,1,1)},e.CreateStorageTexture=function(e,t,r,i,a,u,o,p,s,d){var f,g;void 0===a&&(a=n.Constants.TEXTUREFORMAT_RGBA),void 0===u&&(u=n.Constants.TEXTURETYPE_FLOAT),void 0===o&&(o=n.Constants.TEXTURE_NEAREST_SAMPLINGMODE),void 0===p&&(p=!1),void 0===s&&(s=n.Constants.TEXTURE_WRAP_ADDRESSMODE),void 0===d&&(d=null);var c=d?d.getSize():{width:0,height:0},m=c.width,l=c.height,_=d?null!==(f=d.getInternalTexture().type)&&void 0!==f?f:-1:-2,h=d?null!==(g=d.getInternalTexture().format)&&void 0!==g?g:-1:-2;return-1===_&&(_=n.Constants.TEXTURETYPE_UNSIGNED_BYTE),-1===h&&(h=n.Constants.TEXTUREFORMAT_RGBA),d&&m===r&&l===i&&u===_&&a===h||((d=new n.RawTexture(null,r,i,a,t,p,!1,o,u,n.Constants.TEXTURE_CREATIONFLAG_STORAGE)).name=e),d.wrapU=s,d.wrapV=s,d.updateSamplingMode(o),d},e.CopyTexture=function(t,r,i){var a,u,o=t.getInternalTexture().format===n.Constants.TEXTUREFORMAT_RG?2:4;if(!e._copyTexture4CS&&4===o||!e._copyTexture2CS&&2===o){var p=null!==(u=null===(a=t.getScene())||void 0===a?void 0:a.getEngine())&&void 0!==u?u:i,s=new n.ComputeShader("copyTexture"+o+"Compute",p,{computeSource:4===o?e._copyTexture4ComputeShader:e._copyTexture2ComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),d=new n.UniformBuffer(p);d.addUniform("width",1),d.addUniform("height",1),s.setUniformBuffer("params",d),4===o?(e._copyTexture4CS=s,e._copyTexture4Params=d):(e._copyTexture2CS=s,e._copyTexture2Params=d)}var f=4===o?e._copyTexture4CS:e._copyTexture2CS,g=4===o?e._copyTexture4Params:e._copyTexture2Params;f.setTexture("src",t,!1),f.setStorageTexture("dest",r);var c=t.getSize(),m=c.width,l=c.height;g.updateInt("width",m),g.updateInt("height",l),g.update(),e.Dispatch(f,m,l,1)},e.CopyBufferToTexture=function(t,r){if(!e._copyBufferTextureCS){var i=r.getScene().getEngine(),a=new n.ComputeShader("copyBufferTextureCompute",i,{computeSource:e._copyBufferTextureComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),u=new n.UniformBuffer(i);u.addUniform("width",1),u.addUniform("height",1),a.setUniformBuffer("params",u),e._copyBufferTextureCS=a,e._copyBufferTextureParams=u}e._copyBufferTextureCS.setStorageBuffer("src",t),e._copyBufferTextureCS.setStorageTexture("dest",r);var o=r.getSize(),p=o.width,s=o.height;e._copyBufferTextureParams.updateInt("width",p),e._copyBufferTextureParams.updateInt("height",s),e._copyBufferTextureParams.update(),e.Dispatch(e._copyBufferTextureCS,p,s,1)},e.CopyTextureToBuffer=function(t,r){if(!e._copyTextureBufferCS){var i=t.getScene().getEngine(),a=new n.ComputeShader("copyTextureBufferCompute",i,{computeSource:e._copyTextureBufferComputeShader},{bindingsMapping:{src:{group:0,binding:0},dest:{group:0,binding:1},params:{group:0,binding:2}}}),u=new n.UniformBuffer(i);u.addUniform("width",1),u.addUniform("height",1),a.setUniformBuffer("params",u),e._copyTextureBufferCS=a,e._copyTextureBufferParams=u}e._copyTextureBufferCS.setTexture("src",t,!1),e._copyTextureBufferCS.setStorageBuffer("dest",r);var o=t.getSize(),p=o.width,s=o.height;e._copyTextureBufferParams.updateInt("width",p),e._copyTextureBufferParams.updateInt("height",s),e._copyTextureBufferParams.update(),e.Dispatch(e._copyTextureBufferCS,p,s,1)},e.ClearTexture=function(t,r){if(!e._clearTextureCS){var i=t.getScene().getEngine(),a=new n.ComputeShader("clearTextureCompute",i,{computeSource:e._clearTextureComputeShader},{bindingsMapping:{tbuf:{group:0,binding:0},params:{group:0,binding:1}}}),u=new n.UniformBuffer(i);u.addUniform("color",4),u.addUniform("width",1),u.addUniform("height",1),a.setUniformBuffer("params",u),e._clearTextureCS=a,e._clearTextureParams=u}e._clearTextureCS.setStorageTexture("tbuf",t);var o=t.getSize(),p=o.width,s=o.height;e._clearTextureParams.updateDirectColor4("color",r),e._clearTextureParams.updateInt("width",p),e._clearTextureParams.updateInt("height",s),e._clearTextureParams.update(),e.Dispatch(e._clearTextureCS,p,s,1)},e.Dispatch=function(t,r,n,i){var a;void 0===n&&(n=1),void 0===i&&(i=1),t.threadGroupSizes||(t.threadGroupSizes=e.GetThreadGroupSizes(t.shaderPath.computeSource,null!==(a=t.options.entryPoint)&&void 0!==a?a:"main"));var u=t.threadGroupSizes,o=Math.ceil(r/u.x),p=Math.ceil(n/u.y),s=Math.ceil(i/u.z);t.dispatch(o,p,s)},e._clearTextureComputeShader="\n        @group(0) @binding(0) var tbuf : texture_storage_2d<rgba32float, write>;\n\n        struct Params {\n            color : vec4<f32>;\n            width : u32;\n            height : u32;\n        };\n        @group(0) @binding(1) var<uniform> params : Params;\n\n        @stage(compute) @workgroup_size(8, 8, 1)\n        fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            textureStore(tbuf, vec2<i32>(global_id.xy), params.color);\n        }\n    ",e._copyTexture4ComputeShader="\n        @group(0) @binding(0) var dest : texture_storage_2d<rgba32float, write>;\n        @group(0) @binding(1) var src : texture_2d<f32>;\n\n        struct Params {\n            width : u32;\n            height : u32;\n        };\n        @group(0) @binding(2) var<uniform> params : Params;\n\n        @stage(compute) @workgroup_size(8, 8, 1)\n        fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTexture2ComputeShader="\n        @group(0) @binding(0) var dest : texture_storage_2d<rg32float, write>;\n        @group(0) @binding(1) var src : texture_2d<f32>;\n\n        struct Params {\n            width : u32;\n            height : u32;\n        };\n        @group(0) @binding(2) var<uniform> params : Params;\n\n        @stage(compute) @workgroup_size(8, 8, 1)\n        fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyBufferTextureComputeShader="\n        struct FloatArray {\n            elements : array<f32>;\n        };\n\n        @group(0) @binding(0) var dest : texture_storage_2d<rgba32float, write>;\n        @group(0) @binding(1) var<storage, read> src : FloatArray;\n\n        struct Params {\n            width : u32;\n            height : u32;\n        };\n        @group(0) @binding(2) var<uniform> params : Params;\n\n        @stage(compute) @workgroup_size(8, 8, 1)\n        fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = vec4<f32>(src.elements[offset], src.elements[offset + 1u], src.elements[offset + 2u], src.elements[offset + 3u]);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTextureBufferComputeShader="\n        struct FloatArray {\n            elements : array<f32>;\n        };\n\n        @group(0) @binding(0) var src : texture_2d<f32>;\n        @group(0) @binding(1) var<storage, write> dest : FloatArray;\n\n        struct Params {\n            width : u32;\n            height : u32;\n        };\n        @group(0) @binding(2) var<uniform> params : Params;\n\n        @stage(compute), workgroup_size(8, 8, 1)\n        fn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            dest.elements[offset] = pix.r;\n            dest.elements[offset + 1u] = pix.g;\n            dest.elements[offset + 2u] = pix.b;\n            dest.elements[offset + 3u] = pix.a;\n        }\n    ",e}()}}]);
//# sourceMappingURL=160.babylonBundle.js.map