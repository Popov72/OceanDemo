"use strict";(self.webpackChunkbabylonjs_ocean_demo=self.webpackChunkbabylonjs_ocean_demo||[]).push([[853,193],{389:(e,t,r)=>{r.r(t),r.d(t,{FFT:()=>s});var i=r(6925),n=r(7014);class s{constructor(e,t,r,s,a){this._engine=e,this._rttDebug=r,this._debugFirstIndex=s,this._size=a,this._horizontalStepIFFT=[],this._verticalStepIFFT=[],this._permute=null;const u=new i.ComputeShader("computeTwiddleFactors",this._engine,{computeSource:"const PI: f32 = 3.1415926;\r\n\r\n@group(0) @binding(0) var PrecomputeBuffer : texture_storage_2d<rgba32float, write>;\r\n\r\nstruct Params {\r\n    Step : i32,\r\n    Size : i32,\r\n};\r\n\r\n@group(0) @binding(1) var<uniform> params : Params;\r\n\r\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\r\n}\r\n\r\nfn complexExp(a: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(cos(a.y), sin(a.y)) * exp(a.x);\r\n}\r\n\r\n@compute @workgroup_size(1,8,1)\r\nfn precomputeTwiddleFactorsAndInputIndices(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n\tlet b = params.Size >> (id.x + 1u);\r\n\tlet mult = 2.0 * PI * vec2<f32>(0.0, -1.0) / f32(params.Size);\r\n\tlet i = (2 * b * (iid.y / b) + (iid.y % b)) % params.Size;\r\n\tlet twiddle = complexExp(mult * vec2<f32>(f32((iid.y / b) * b)));\r\n\t\r\n    textureStore(PrecomputeBuffer, iid.xy, vec4<f32>(twiddle.x, twiddle.y, f32(i), f32(i + b)));\r\n\ttextureStore(PrecomputeBuffer, vec2<i32>(iid.x, iid.y + params.Size / 2), vec4<f32>(-twiddle.x, -twiddle.y, f32(i), f32(i + b)));\r\n}\r\n"},{bindingsMapping:{PrecomputeBuffer:{group:0,binding:0},params:{group:0,binding:1}},entryPoint:"precomputeTwiddleFactorsAndInputIndices"}),p=0|Math.log2(a);this._precomputedData=n.ComputeHelper.CreateStorageTexture("precomputeTwiddle",this._engine,p,this._size,i.Constants.TEXTUREFORMAT_RGBA),this._rttDebug.setTexture(this._debugFirstIndex,"precomputeTwiddle",this._precomputedData),this._params=new i.UniformBuffer(this._engine),this._params.addUniform("Step",1),this._params.addUniform("Size",1),u.setStorageTexture("PrecomputeBuffer",this._precomputedData),u.setUniformBuffer("params",this._params),this._params.updateInt("Size",this._size),this._params.update(),n.ComputeHelper.Dispatch(u,p,a/2,1),this._createComputeShaders()}IFFT2D(e,t){const r=0|Math.log2(this._size);let i=!1;for(let s=0;s<r;++s)i=!i,this._params.updateInt("Step",s),this._params.update(),this._horizontalStepIFFT[0].setTexture("InputBuffer",i?e:t,!1),this._horizontalStepIFFT[0].setStorageTexture("OutputBuffer",i?t:e),n.ComputeHelper.Dispatch(this._horizontalStepIFFT[0],this._size,this._size,1);for(let s=0;s<r;++s)i=!i,this._params.updateInt("Step",s),this._params.update(),this._verticalStepIFFT[0].setTexture("InputBuffer",i?e:t,!1),this._verticalStepIFFT[0].setStorageTexture("OutputBuffer",i?t:e),n.ComputeHelper.Dispatch(this._verticalStepIFFT[0],this._size,this._size,1);i&&n.ComputeHelper.CopyTexture(t,e,this._engine),this._permute.setTexture("InputBuffer",e,!1),this._permute.setStorageTexture("OutputBuffer",t),n.ComputeHelper.Dispatch(this._permute,this._size,this._size,1),n.ComputeHelper.CopyTexture(t,e,this._engine)}dispose(){this._precomputedData.dispose(),this._params.dispose()}_createComputeShaders(){for(let e=0;e<2;++e)this._horizontalStepIFFT[e]=new i.ComputeShader("horizontalStepIFFT",this._engine,{computeSource:"struct Params {\r\n    Step : i32,\r\n    Size : i32,\r\n};\r\n\r\n@group(0) @binding(1) var<uniform> params : Params;\r\n\r\n@group(0) @binding(3) var PrecomputedData : texture_2d<f32>;\r\n\r\n@group(0) @binding(5) var InputBuffer : texture_2d<f32>;\r\n@group(0) @binding(6) var OutputBuffer : texture_storage_2d<rg32float, write>;\r\n\r\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\r\n}\r\n\r\n@compute @workgroup_size(8,8,1)\r\nfn horizontalStepInverseFFT(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n    let data = textureLoad(PrecomputedData, vec2<i32>(params.Step, iid.x), 0);\r\n\tlet inputsIndices = vec2<i32>(data.ba);\r\n\r\n    let input0 = textureLoad(InputBuffer, vec2<i32>(inputsIndices.x, iid.y), 0);\r\n    let input1 = textureLoad(InputBuffer, vec2<i32>(inputsIndices.y, iid.y), 0);\r\n\r\n    textureStore(OutputBuffer, iid.xy, vec4<f32>(\r\n        input0.xy + complexMult(vec2<f32>(data.r, -data.g), input1.xy), 0., 0.\r\n    ));\r\n}\r\n"},{bindingsMapping:{params:{group:0,binding:1},PrecomputedData:{group:0,binding:3},InputBuffer:{group:0,binding:5},OutputBuffer:{group:0,binding:6}},entryPoint:"horizontalStepInverseFFT"}),this._horizontalStepIFFT[e].setUniformBuffer("params",this._params),this._horizontalStepIFFT[e].setTexture("PrecomputedData",this._precomputedData,!1),this._verticalStepIFFT[e]=new i.ComputeShader("verticalStepIFFT",this._engine,{computeSource:"struct Params {\r\n    Step : i32,\r\n    Size : i32,\r\n};\r\n\r\n@group(0) @binding(1) var<uniform> params : Params;\r\n\r\n@group(0) @binding(3) var PrecomputedData : texture_2d<f32>;\r\n\r\n@group(0) @binding(5) var InputBuffer : texture_2d<f32>;\r\n@group(0) @binding(6) var OutputBuffer : texture_storage_2d<rg32float, write>;\r\n\r\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\r\n}\r\n\r\n@compute @workgroup_size(8,8,1)\r\nfn verticalStepInverseFFT(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n    let data = textureLoad(PrecomputedData, vec2<i32>(params.Step, iid.y), 0);\r\n\tlet inputsIndices = vec2<i32>(data.ba);\r\n\r\n    let input0 = textureLoad(InputBuffer, vec2<i32>(iid.x, inputsIndices.x), 0);\r\n    let input1 = textureLoad(InputBuffer, vec2<i32>(iid.x, inputsIndices.y), 0);\r\n\r\n    textureStore(OutputBuffer, iid.xy, vec4<f32>(\r\n        input0.xy + complexMult(vec2<f32>(data.r, -data.g), input1.xy), 0., 0.\r\n    ));\r\n}\r\n"},{bindingsMapping:{params:{group:0,binding:1},PrecomputedData:{group:0,binding:3},InputBuffer:{group:0,binding:5},OutputBuffer:{group:0,binding:6}},entryPoint:"verticalStepInverseFFT"}),this._verticalStepIFFT[e].setUniformBuffer("params",this._params),this._verticalStepIFFT[e].setTexture("PrecomputedData",this._precomputedData,!1);this._permute=new i.ComputeShader("permute",this._engine,{computeSource:"@group(0) @binding(5) var InputBuffer : texture_2d<f32>;\r\n@group(0) @binding(6) var OutputBuffer : texture_storage_2d<rg32float, write>;\r\n\r\n@compute @workgroup_size(8,8,1)\r\nfn permute(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n    let input = textureLoad(InputBuffer, iid.xy, 0);\r\n\r\n    textureStore(OutputBuffer, iid.xy, input * (1.0 - 2.0 * f32((iid.x + iid.y) % 2)));\r\n}\r\n"},{bindingsMapping:{InputBuffer:{group:0,binding:5},OutputBuffer:{group:0,binding:6}},entryPoint:"permute"})}}},7193:(e,t,r)=>{r.r(t),r.d(t,{WavesCascade:()=>a});var i=r(6925),n=r(6093),s=r(7014);class a{constructor(e,t,r,a,u,p){this._engine=p,this._size=e,this._fft=r,this._lambda=0,this._pingPongTurbulence=!1,this._initialSpectrum=new n.InitialSpectrum(p,a,u,e,t),this._timeDependentSpectrum=new i.ComputeShader("timeDependentSpectrumCS",this._engine,{computeSource:"@group(0) @binding(1) var H0 : texture_2d<f32>;\r\n@group(0) @binding(3) var WavesData : texture_2d<f32>;\r\n\r\nstruct Params {\r\n    Time : f32,\r\n};\r\n\r\n@group(0) @binding(4) var<uniform> params : Params;\r\n\r\n@group(0) @binding(5) var DxDz : texture_storage_2d<rg32float, write>;\r\n@group(0) @binding(6) var DyDxz : texture_storage_2d<rg32float, write>;\r\n@group(0) @binding(7) var DyxDyz : texture_storage_2d<rg32float, write>;\r\n@group(0) @binding(8) var DxxDzz : texture_storage_2d<rg32float, write>;\r\n\r\nfn complexMult(a: vec2<f32>, b: vec2<f32>) -> vec2<f32>\r\n{\r\n\treturn vec2<f32>(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);\r\n}\r\n\r\n@compute @workgroup_size(8,8,1)\r\nfn calculateAmplitudes(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n\tlet wave = textureLoad(WavesData, iid.xy, 0);\r\n\tlet phase = wave.w * params.Time;\r\n\tlet exponent = vec2<f32>(cos(phase), sin(phase));\r\n    let h0 = textureLoad(H0, iid.xy, 0);\r\n\tlet h = complexMult(h0.xy, exponent) + complexMult(h0.zw, vec2<f32>(exponent.x, -exponent.y));\r\n\tlet ih = vec2<f32>(-h.y, h.x);\r\n\r\n\tlet displacementX = ih * wave.x * wave.y;\r\n\tlet displacementY = h;\r\n\tlet displacementZ = ih * wave.z * wave.y;\r\n\r\n\tlet displacementX_dx = -h * wave.x * wave.x * wave.y;\r\n\tlet displacementY_dx = ih * wave.x;\r\n\tlet displacementZ_dx = -h * wave.x * wave.z * wave.y;\r\n\t\t \r\n\tlet displacementY_dz = ih * wave.z;\r\n\tlet displacementZ_dz = -h * wave.z * wave.z * wave.y;\r\n\r\n\ttextureStore(DxDz,   iid.xy, vec4<f32>(displacementX.x - displacementZ.y, displacementX.y + displacementZ.x, 0., 0.));\r\n\ttextureStore(DyDxz,  iid.xy, vec4<f32>(displacementY.x - displacementZ_dx.y, displacementY.y + displacementZ_dx.x, 0., 0.));\r\n\ttextureStore(DyxDyz, iid.xy, vec4<f32>(displacementY_dx.x - displacementY_dz.y, displacementY_dx.y + displacementY_dz.x, 0., 0.));\r\n\ttextureStore(DxxDzz, iid.xy, vec4<f32>(displacementX_dx.x - displacementZ_dz.y, displacementX_dx.y + displacementZ_dz.x, 0., 0.));\r\n}\r\n"},{bindingsMapping:{H0:{group:0,binding:1},WavesData:{group:0,binding:3},params:{group:0,binding:4},DxDz:{group:0,binding:5},DyDxz:{group:0,binding:6},DyxDyz:{group:0,binding:7},DxxDzz:{group:0,binding:8}},entryPoint:"calculateAmplitudes"}),this._buffer=s.ComputeHelper.CreateStorageTexture("buffer",this._engine,this._size,this._size,i.Constants.TEXTUREFORMAT_RG),this._DxDz=s.ComputeHelper.CreateStorageTexture("DxDz",this._engine,this._size,this._size,i.Constants.TEXTUREFORMAT_RG),this._DyDxz=s.ComputeHelper.CreateStorageTexture("DyDxz",this._engine,this._size,this._size,i.Constants.TEXTUREFORMAT_RG),this._DyxDyz=s.ComputeHelper.CreateStorageTexture("DyxDyz",this._engine,this._size,this._size,i.Constants.TEXTUREFORMAT_RG),this._DxxDzz=s.ComputeHelper.CreateStorageTexture("DxxDzz",this._engine,this._size,this._size,i.Constants.TEXTUREFORMAT_RG),this._timeDependentSpectrumParams=new i.UniformBuffer(this._engine),this._timeDependentSpectrumParams.addUniform("Time",1),this._timeDependentSpectrum.setTexture("H0",this._initialSpectrum.initialSpectrum,!1),this._timeDependentSpectrum.setTexture("WavesData",this._initialSpectrum.wavesData,!1),this._timeDependentSpectrum.setUniformBuffer("params",this._timeDependentSpectrumParams),this._timeDependentSpectrum.setStorageTexture("DxDz",this._DxDz),this._timeDependentSpectrum.setStorageTexture("DyDxz",this._DyDxz),this._timeDependentSpectrum.setStorageTexture("DyxDyz",this._DyxDyz),this._timeDependentSpectrum.setStorageTexture("DxxDzz",this._DxxDzz),a.setTexture(u+3,"DxDz",this._DxDz,2),a.setTexture(u+4,"DyDxz",this._DyDxz,2),a.setTexture(u+5,"DyxDyz",this._DyxDyz,2),a.setTexture(u+6,"DxxDzz",this._DxxDzz,2),this._texturesMerger=new i.ComputeShader("texturesMerger",this._engine,{computeSource:"struct Params {\r\n    Lambda : f32,\r\n    DeltaTime : f32,\r\n};\r\n\r\n@group(0) @binding(0) var<uniform> params : Params;\r\n\r\n@group(0) @binding(1) var Displacement : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(2) var Derivatives : texture_storage_2d<rgba16float, write>;\r\n@group(0) @binding(3) var TurbulenceRead : texture_2d<f32>;\r\n@group(0) @binding(4) var TurbulenceWrite : texture_storage_2d<rgba16float, write>;\r\n\r\n@group(0) @binding(5) var Dx_Dz : texture_2d<f32>;\r\n@group(0) @binding(6) var Dy_Dxz : texture_2d<f32>;\r\n@group(0) @binding(7) var Dyx_Dyz : texture_2d<f32>;\r\n@group(0) @binding(8) var Dxx_Dzz : texture_2d<f32>;\r\n\r\n@compute @workgroup_size(8,8,1)\r\nfn fillResultTextures(@builtin(global_invocation_id) id : vec3<u32>)\r\n{\r\n    let iid = vec3<i32>(id);\r\n\r\n\tlet DxDz = textureLoad(Dx_Dz, iid.xy, 0);\r\n\tlet DyDxz = textureLoad(Dy_Dxz, iid.xy, 0);\r\n\tlet DyxDyz = textureLoad(Dyx_Dyz, iid.xy, 0);\r\n\tlet DxxDzz = textureLoad(Dxx_Dzz, iid.xy, 0);\r\n\t\r\n\ttextureStore(Displacement, iid.xy, vec4<f32>(params.Lambda * DxDz.x, DyDxz.x, params.Lambda * DxDz.y, 0.));\r\n\ttextureStore(Derivatives, iid.xy, vec4<f32>(DyxDyz.x, DyxDyz.y, DxxDzz.x * params.Lambda, DxxDzz.y * params.Lambda));\r\n\r\n\tlet jacobian = (1.0 + params.Lambda * DxxDzz.x) * (1.0 + params.Lambda * DxxDzz.y) - params.Lambda * params.Lambda * DyDxz.y * DyDxz.y;\r\n\r\n    var turbulence = textureLoad(TurbulenceRead, iid.xy, 0).r + params.DeltaTime * 0.5 / max(jacobian, 0.5);\r\n    turbulence = min(jacobian, turbulence);\r\n\r\n    textureStore(TurbulenceWrite, iid.xy, vec4<f32>(turbulence, turbulence, turbulence, 1.));\r\n}\r\n"},{bindingsMapping:{params:{group:0,binding:0},Displacement:{group:0,binding:1},Derivatives:{group:0,binding:2},TurbulenceRead:{group:0,binding:3},TurbulenceWrite:{group:0,binding:4},DxDz:{group:0,binding:5},DyDxz:{group:0,binding:6},DyxDyz:{group:0,binding:7},DxxDzz:{group:0,binding:8}},entryPoint:"fillResultTextures"}),this._displacement=s.ComputeHelper.CreateStorageTexture("displacement",this._engine,this._size,this._size,i.Constants.TEXTUREFORMAT_RGBA,i.Constants.TEXTURETYPE_HALF_FLOAT,i.Constants.TEXTURE_BILINEAR_SAMPLINGMODE),this._derivatives=s.ComputeHelper.CreateStorageTexture("derivatives",this._engine,this._size,this._size,i.Constants.TEXTUREFORMAT_RGBA,i.Constants.TEXTURETYPE_HALF_FLOAT,i.Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,!0),this._turbulence=s.ComputeHelper.CreateStorageTexture("turbulence",this._engine,this._size,this._size,i.Constants.TEXTUREFORMAT_RGBA,i.Constants.TEXTURETYPE_HALF_FLOAT,i.Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,!0),this._turbulence2=s.ComputeHelper.CreateStorageTexture("turbulence",this._engine,this._size,this._size,i.Constants.TEXTUREFORMAT_RGBA,i.Constants.TEXTURETYPE_HALF_FLOAT,i.Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,!0),this._texturesMergerParams=new i.UniformBuffer(this._engine),this._texturesMergerParams.addUniform("Lambda",1),this._texturesMergerParams.addUniform("DeltaTime",1),this._texturesMerger.setUniformBuffer("params",this._texturesMergerParams),this._texturesMerger.setStorageTexture("Displacement",this._displacement),this._texturesMerger.setStorageTexture("Derivatives",this._derivatives),this._texturesMerger.setTexture("DxDz",this._DxDz,!1),this._texturesMerger.setTexture("DyDxz",this._DyDxz,!1),this._texturesMerger.setTexture("DyxDyz",this._DyxDyz,!1),this._texturesMerger.setTexture("DxxDzz",this._DxxDzz,!1),a.setTexture(u+7,"displacement",this._displacement,2),a.setTexture(u+8,"derivatives",this._derivatives,2),a.setTexture(u+9,"turbulence",this._turbulence,1)}get displacement(){return this._displacement}get derivatives(){return this._derivatives}get turbulence(){return this._pingPongTurbulence?this._turbulence2:this._turbulence}calculateInitials(e,t,r,i){this._lambda=e.lambda,this._initialSpectrum.generate(e,t,r,i)}calculateWavesAtTime(e){this._timeDependentSpectrumParams.updateFloat("Time",e),this._timeDependentSpectrumParams.update(),s.ComputeHelper.Dispatch(this._timeDependentSpectrum,this._size,this._size,1),this._fft.IFFT2D(this._DxDz,this._buffer),this._fft.IFFT2D(this._DyDxz,this._buffer),this._fft.IFFT2D(this._DyxDyz,this._buffer),this._fft.IFFT2D(this._DxxDzz,this._buffer);let t=this._engine.getDeltaTime()/1e3;t>.5&&(t=.5),this._texturesMergerParams.updateFloat("Lambda",this._lambda),this._texturesMergerParams.updateFloat("DeltaTime",t),this._texturesMergerParams.update(),this._pingPongTurbulence=!this._pingPongTurbulence,this._texturesMerger.setTexture("TurbulenceRead",this._pingPongTurbulence?this._turbulence:this._turbulence2,!1),this._texturesMerger.setStorageTexture("TurbulenceWrite",this._pingPongTurbulence?this._turbulence2:this._turbulence),s.ComputeHelper.Dispatch(this._texturesMerger,this._size,this._size,1),this._engine.generateMipmaps(this._derivatives.getInternalTexture()),this._engine.generateMipmaps(this._pingPongTurbulence?this._turbulence2.getInternalTexture():this._turbulence.getInternalTexture())}dispose(){this._initialSpectrum.dispose(),this._timeDependentSpectrumParams.dispose(),this._buffer.dispose(),this._DxDz.dispose(),this._DyDxz.dispose(),this._DyxDyz.dispose(),this._DxxDzz.dispose(),this._texturesMergerParams.dispose()}}},6853:(e,t,r)=>{r.r(t),r.d(t,{WavesGenerator:()=>a});var i=r(6925),n=r(389),s=r(7193);class a{constructor(e,t,r,i,a){this._engine=r.getEngine(),this._rttDebug=i,this._startTime=(new Date).getTime()/1e3,this._displacementMap=null,this._wavesSettings=t,this._fft=new n.FFT(r.getEngine(),r,this._rttDebug,1,e),this._noise=this._generateNoiseTexture(e,a),this._rttDebug.setTexture(0,"noise",this._noise),this.lengthScale=[250,17,5],this._cascades=[new s.WavesCascade(e,this._noise,this._fft,this._rttDebug,2,this._engine),new s.WavesCascade(e,this._noise,this._fft,this._rttDebug,12,this._engine),new s.WavesCascade(e,this._noise,this._fft,this._rttDebug,22,this._engine)],this.initializeCascades()}getCascade(e){return this._cascades[e]}get waterHeightMap(){return this._displacementMap}get waterHeightMapScale(){return this.lengthScale[0]}initializeCascades(){let e=1e-4;for(let t=0;t<this.lengthScale.length;++t){const r=t<this.lengthScale.length-1?2*Math.PI/this.lengthScale[t+1]*6:9999;this._cascades[t].calculateInitials(this._wavesSettings,this.lengthScale[t],e,r),e=r}}update(){const e=(new Date).getTime()/1e3-this._startTime;for(let t=0;t<this._cascades.length;++t)this._cascades[t].calculateWavesAtTime(e);this._getDisplacementMap()}dispose(){for(let e=0;e<this._cascades.length;++e)this._cascades[e].dispose();this._noise.dispose(),this._fft.dispose()}_getDisplacementMap(){var e;null===(e=this._cascades[0].displacement.readPixels(void 0,void 0,void 0,void 0,!0))||void 0===e||e.then((e=>{this._displacementMap=new Uint16Array(e.buffer)}))}_normalRandom(){return Math.cos(2*Math.PI*Math.random())*Math.sqrt(-2*Math.log(Math.random()))}_generateNoiseTexture(e,t){const r=t?4:2,n=new Float32Array(e*e*r);if(t){const e=new Uint8Array(t),r=new Uint8Array(4),i=new Float32Array(r.buffer,0,1);let s=2379,a=0;for(let t=0;t<256;++t){s+=8,s+=1024,s+=1024;for(let t=0;t<256;++t)r[0]=e[s++],r[1]=e[s++],r[2]=e[s++],r[3]=e[s++],n[a+1+4*t]=i[0];for(let t=0;t<256;++t)r[0]=e[s++],r[1]=e[s++],r[2]=e[s++],r[3]=e[s++],n[a+0+4*t]=i[0];for(let e=0;e<256;++e)n[a+3+4*e]=1;a+=1024}}else for(let t=0;t<e;++t)for(let r=0;r<e;++r)n[r*e*2+2*t+0]=this._normalRandom(),n[r*e*2+2*t+1]=this._normalRandom();const s=new i.RawTexture(n,e,e,2===r?i.Constants.TEXTUREFORMAT_RG:i.Constants.TEXTUREFORMAT_RGBA,this._engine,!1,!1,i.Constants.TEXTURE_NEAREST_SAMPLINGMODE,i.Constants.TEXTURETYPE_FLOAT);return s.name="noise",s}}}}]);
//# sourceMappingURL=853.d4625efb9daf3af292a1.js.map