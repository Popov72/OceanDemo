(self.webpackChunkbabylonjs_typescript_webpack_simple_scene=self.webpackChunkbabylonjs_typescript_webpack_simple_scene||[]).push([[14],{7014:(e,r,t)=>{"use strict";t.r(r),t.d(r,{ComputeHelper:()=>a});var n=t(6506),a=function(){function e(){}return e.GetThreadGroupSizes=function(e,r){var t=new RegExp("workgroup_size\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)]]\\s*fn\\s+"+r+"\\s*\\(","g").exec(e);return t?new n.Vector3(parseInt(t[1]),parseInt(t[2]),parseInt(t[3])):new n.Vector3(1,1,1)},e.CreateStorageTexture=function(e,r,t,a,i,o,u,s,p,d){var g,f;void 0===i&&(i=n.Constants.TEXTUREFORMAT_RGBA),void 0===o&&(o=n.Constants.TEXTURETYPE_FLOAT),void 0===u&&(u=n.Constants.TEXTURE_NEAREST_SAMPLINGMODE),void 0===s&&(s=!1),void 0===p&&(p=n.Constants.TEXTURE_WRAP_ADDRESSMODE),void 0===d&&(d=null);var c=d?d.getSize():{width:0,height:0},l=c.width,m=c.height,_=d?null!==(g=d.getInternalTexture().type)&&void 0!==g?g:-1:-2,h=d?null!==(f=d.getInternalTexture().format)&&void 0!==f?f:-1:-2;return-1===_&&(_=n.Constants.TEXTURETYPE_UNSIGNED_BYTE),-1===h&&(h=n.Constants.TEXTUREFORMAT_RGBA),d&&l===t&&m===a&&o===_&&i===h||((d=new n.RawTexture(null,t,a,i,r,s,!1,u,o,n.Constants.TEXTURE_CREATIONFLAG_STORAGE)).name=e),d.wrapU=p,d.wrapV=p,d.updateSamplingMode(u),d},e.CopyTexture=function(r,t,a){var i,o,u=r.getInternalTexture().format===n.Constants.TEXTUREFORMAT_RG?2:4;if(!e._copyTexture4CS&&4===u||!e._copyTexture2CS&&2===u){var s=null!==(o=null===(i=r.getScene())||void 0===i?void 0:i.getEngine())&&void 0!==o?o:a,p=new n.ComputeShader("copyTexture"+u+"Compute",s,{computeSource:4===u?e._copyTexture4ComputeShader:e._copyTexture2ComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),d=new n.UniformBuffer(s);d.addUniform("width",1),d.addUniform("height",1),p.setUniformBuffer("params",d),4===u?(e._copyTexture4CS=p,e._copyTexture4Params=d):(e._copyTexture2CS=p,e._copyTexture2Params=d)}var g=4===u?e._copyTexture4CS:e._copyTexture2CS,f=4===u?e._copyTexture4Params:e._copyTexture2Params;g.setTexture("src",r,!1),g.setStorageTexture("dest",t);var c=r.getSize(),l=c.width,m=c.height;f.updateInt("width",l),f.updateInt("height",m),f.update(),e.Dispatch(g,l,m,1)},e.CopyBufferToTexture=function(r,t){if(!e._copyBufferTextureCS){var a=t.getScene().getEngine(),i=new n.ComputeShader("copyBufferTextureCompute",a,{computeSource:e._copyBufferTextureComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),o=new n.UniformBuffer(a);o.addUniform("width",1),o.addUniform("height",1),i.setUniformBuffer("params",o),e._copyBufferTextureCS=i,e._copyBufferTextureParams=o}e._copyBufferTextureCS.setStorageBuffer("src",r),e._copyBufferTextureCS.setStorageTexture("dest",t);var u=t.getSize(),s=u.width,p=u.height;e._copyBufferTextureParams.updateInt("width",s),e._copyBufferTextureParams.updateInt("height",p),e._copyBufferTextureParams.update(),e.Dispatch(e._copyBufferTextureCS,s,p,1)},e.CopyTextureToBuffer=function(r,t){if(!e._copyTextureBufferCS){var a=r.getScene().getEngine(),i=new n.ComputeShader("copyTextureBufferCompute",a,{computeSource:e._copyTextureBufferComputeShader},{bindingsMapping:{src:{group:0,binding:0},dest:{group:0,binding:1},params:{group:0,binding:2}}}),o=new n.UniformBuffer(a);o.addUniform("width",1),o.addUniform("height",1),i.setUniformBuffer("params",o),e._copyTextureBufferCS=i,e._copyTextureBufferParams=o}e._copyTextureBufferCS.setTexture("src",r,!1),e._copyTextureBufferCS.setStorageBuffer("dest",t);var u=r.getSize(),s=u.width,p=u.height;e._copyTextureBufferParams.updateInt("width",s),e._copyTextureBufferParams.updateInt("height",p),e._copyTextureBufferParams.update(),e.Dispatch(e._copyTextureBufferCS,s,p,1)},e.ClearTexture=function(r,t){if(!e._clearTextureCS){var a=r.getScene().getEngine(),i=new n.ComputeShader("clearTextureCompute",a,{computeSource:e._clearTextureComputeShader},{bindingsMapping:{tbuf:{group:0,binding:0},params:{group:0,binding:1}}}),o=new n.UniformBuffer(a);o.addUniform("color",4),o.addUniform("width",1),o.addUniform("height",1),i.setUniformBuffer("params",o),e._clearTextureCS=i,e._clearTextureParams=o}e._clearTextureCS.setStorageTexture("tbuf",r);var u=r.getSize(),s=u.width,p=u.height;e._clearTextureParams.updateDirectColor4("color",t),e._clearTextureParams.updateInt("width",s),e._clearTextureParams.updateInt("height",p),e._clearTextureParams.update(),e.Dispatch(e._clearTextureCS,s,p,1)},e.Dispatch=function(r,t,n,a){var i;void 0===n&&(n=1),void 0===a&&(a=1),r.threadGroupSizes||(r.threadGroupSizes=e.GetThreadGroupSizes(r.shaderPath.computeSource,null!==(i=r.options.entryPoint)&&void 0!==i?i:"main"));var o=r.threadGroupSizes,u=Math.ceil(t/o.x),s=Math.ceil(n/o.y),p=Math.ceil(a/o.z);r.dispatch(u,s,p)},e._clearTextureComputeShader="\n        [[group(0), binding(0)]] var tbuf : texture_storage_2d<rgba32float, write>;\n\n        [[block]] struct Params {\n            color : vec4<f32>;\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(1)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            textureStore(tbuf, vec2<i32>(global_id.xy), params.color);\n        }\n    ",e._copyTexture4ComputeShader="\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba32float, write>;\n        [[group(0), binding(1)]] var src : texture_2d<f32>;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTexture2ComputeShader="\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rg32float, write>;\n        [[group(0), binding(1)]] var src : texture_2d<f32>;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyBufferTextureComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba32float, write>;\n        [[group(0), binding(1)]] var<storage, read> src : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = vec4<f32>(src.elements[offset], src.elements[offset + 1u], src.elements[offset + 2u], src.elements[offset + 3u]);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTextureBufferComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var src : texture_2d<f32>;\n        [[group(0), binding(1)]] var<storage, write> dest : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            dest.elements[offset] = pix.r;\n            dest.elements[offset + 1u] = pix.g;\n            dest.elements[offset + 2u] = pix.b;\n            dest.elements[offset + 3u] = pix.a;\n        }\n    ",e}()}}]);
//# sourceMappingURL=14.babylonBundle.js.map