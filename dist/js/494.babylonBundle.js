(self.webpackChunkbabylonjs_ocean_demo=self.webpackChunkbabylonjs_ocean_demo||[]).push([[494,14],{494:(e,t,r)=>{"use strict";r.r(t),r.d(t,{InitialSpectrum:()=>i});var a=r(2264),n=r(7014),i=function(){function e(e,t,r,i,s){this._engine=e,this._rttDebug=t,this._debugFirstIndex=r,this._textureSize=i,this._phase1=new a.ComputeShader("initialSpectrum",this._engine,{computeSource:"let PI : f32 = 3.1415926;\r\n\r\n[[group(0), binding(1)]] var WavesData : texture_storage_2d<rgba32float, write>;\r\n[[group(0), binding(2)]] var H0K : texture_storage_2d<rg32float, write>;\r\n[[group(0), binding(4)]] var Noise : texture_2d<f32>;\r\n\r\n[[block]] struct Params {\r\n    Size : u32;\r\n    LengthScale : f32;\r\n    CutoffHigh : f32;\r\n    CutoffLow : f32;\r\n    GravityAcceleration : f32;\r\n    Depth : f32;\r\n};\r\n\r\n[[group(0), binding(5)]] var<uniform> params : Params;\r\n\r\nstruct SpectrumParameter {\r\n\tscale : f32;\r\n\tangle : f32;\r\n\tspreadBlend : f32;\r\n\tswell : f32;\r\n\talpha : f32;\r\n\tpeakOmega : f32;\r\n\tgamma : f32;\r\n\tshortWavesFade : f32;\r\n};\r\n\r\n[[block]] struct SpectrumParameters {\r\n    elements : array<SpectrumParameter>;\r\n};\r\n\r\n[[group(0), binding(6)]] var<storage, read> spectrums : SpectrumParameters;\r\n\r\nfn frequency(k: f32, g: f32, depth: f32) -> f32\r\n{\r\n\treturn sqrt(g * k * tanh(min(k * depth, 20.0)));\r\n}\r\n\r\nfn frequencyDerivative(k: f32, g: f32, depth: f32) -> f32\r\n{\r\n\tlet th = tanh(min(k * depth, 20.0));\r\n\tlet ch = cosh(k * depth);\r\n\treturn g * (depth * k / ch / ch + th) / frequency(k, g, depth) / 2.0;\r\n}\r\n\r\nfn normalisationFactor(s: f32) -> f32\r\n{\r\n\tlet s2 = s * s;\r\n\tlet s3 = s2 * s;\r\n\tlet s4 = s3 * s;\r\n\tif (s < 5.0) {\r\n\t\treturn -0.000564 * s4 + 0.00776 * s3 - 0.044 * s2 + 0.192 * s + 0.163;\r\n    }\r\n\treturn -4.80e-08 * s4 + 1.07e-05 * s3 - 9.53e-04 * s2 + 5.90e-02 * s + 3.93e-01;\r\n}\r\n\r\nfn cosine2s(theta: f32, s: f32) -> f32\r\n{\r\n\treturn normalisationFactor(s) * pow(abs(cos(0.5 * theta)), 2.0 * s);\r\n}\r\n\r\nfn spreadPower(omega: f32, peakOmega: f32) -> f32\r\n{\r\n\tif (omega > peakOmega) {\r\n\t\treturn 9.77 * pow(abs(omega / peakOmega), -2.5);\r\n\t}\r\n\treturn 6.97 * pow(abs(omega / peakOmega), 5.0);\r\n}\r\n\r\nfn directionSpectrum(theta: f32, omega: f32, pars: SpectrumParameter) -> f32\r\n{\r\n\tlet s = spreadPower(omega, pars.peakOmega) + 16.0 * tanh(min(omega / pars.peakOmega, 20.0)) * pars.swell * pars.swell;\r\n\treturn mix(2.0 / PI * cos(theta) * cos(theta), cosine2s(theta - pars.angle, s), pars.spreadBlend);\r\n}\r\n\r\nfn TMACorrection(omega: f32, g: f32, depth: f32) -> f32\r\n{\r\n\tlet omegaH = omega * sqrt(depth / g);\r\n\tif (omegaH <= 1.0) {\r\n\t\treturn 0.5 * omegaH * omegaH;\r\n    }\r\n\tif (omegaH < 2.0) {\r\n\t\treturn 1.0 - 0.5 * (2.0 - omegaH) * (2.0 - omegaH);\r\n    }\r\n\treturn 1.0;\r\n}\r\n\r\nfn JONSWAP(omega: f32, g: f32, depth: f32, pars: SpectrumParameter) -> f32\r\n{\r\n\tvar sigma: f32;\r\n\tif (omega <= pars.peakOmega) {\r\n\t\tsigma = 0.07;\r\n    } else {\r\n\t\tsigma = 0.09;\r\n    }\r\n\tlet r = exp(-(omega - pars.peakOmega) * (omega - pars.peakOmega) / 2.0 / sigma / sigma / pars.peakOmega / pars.peakOmega);\r\n\t\r\n\tlet oneOverOmega = 1.0 / omega;\r\n\tlet peakOmegaOverOmega = pars.peakOmega / omega;\r\n\r\n\treturn pars.scale * TMACorrection(omega, g, depth) * pars.alpha * g * g\r\n\t\t* oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega\r\n\t\t* exp(-1.25 * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega)\r\n\t\t* pow(abs(pars.gamma), r);\r\n}\r\n\r\nfn shortWavesFade(kLength: f32, pars: SpectrumParameter) -> f32\r\n{\r\n\treturn exp(-pars.shortWavesFade * pars.shortWavesFade * kLength * kLength);\r\n}\r\n\r\n[[stage(compute), workgroup_size(8,8,1)]]\r\nfn calculateInitialSpectrum([[builtin(global_invocation_id)]] id : vec3<u32>)\r\n{\r\n\tlet deltaK = 2.0 * PI / params.LengthScale;\r\n\tlet nx = f32(id.x) - f32(params.Size) / 2.0;\r\n\tlet nz = f32(id.y) - f32(params.Size) / 2.0;\r\n\tlet k = vec2<f32>(nx, nz) * deltaK;\r\n\tlet kLength = length(k);\r\n\r\n\tif (kLength <= params.CutoffHigh && kLength >= params.CutoffLow) {\r\n\t\tlet omega = frequency(kLength, params.GravityAcceleration, params.Depth);\r\n\t\ttextureStore(WavesData, vec2<i32>(id.xy), vec4<f32>(k.x, 1.0 / kLength, k.y, omega));\r\n\r\n\t\tlet kAngle = atan2(k.y, k.x);\r\n\t\tlet dOmegadk = frequencyDerivative(kLength, params.GravityAcceleration, params.Depth);\r\n\t\tvar spectrum = JONSWAP(omega, params.GravityAcceleration, params.Depth, spectrums.elements[0]) * directionSpectrum(kAngle, omega, spectrums.elements[0]) * shortWavesFade(kLength, spectrums.elements[0]);\r\n\t\tif (spectrums.elements[1].scale > 0.0) {\r\n\t\t\tspectrum = spectrum + JONSWAP(omega, params.GravityAcceleration, params.Depth, spectrums.elements[1]) * directionSpectrum(kAngle, omega, spectrums.elements[1]) * shortWavesFade(kLength, spectrums.elements[1]);\r\n        }\r\n        let noise = textureLoad(Noise, vec2<i32>(id.xy), 0).xy;\r\n        textureStore(H0K, vec2<i32>(id.xy), vec4<f32>(noise * sqrt(2.0 * spectrum * abs(dOmegadk) / kLength * deltaK * deltaK), 0., 0.));\r\n\t} else {\r\n\t\ttextureStore(H0K, vec2<i32>(id.xy), vec4<f32>(0.0));\r\n\t\ttextureStore(WavesData, vec2<i32>(id.xy), vec4<f32>(k.x, 1.0, k.y, 0.0));\r\n\t}    \r\n}\r\n"},{bindingsMapping:{WavesData:{group:0,binding:1},H0K:{group:0,binding:2},Noise:{group:0,binding:4},params:{group:0,binding:5},spectrumParameters:{group:0,binding:6}},entryPoint:"calculateInitialSpectrum"}),this._initialSpectrum=n.ComputeHelper.CreateStorageTexture("h0",e,i,i,a.Constants.TEXTUREFORMAT_RGBA),this._precomputedData=n.ComputeHelper.CreateStorageTexture("wavesData",e,i,i,a.Constants.TEXTUREFORMAT_RGBA),this._buffer=n.ComputeHelper.CreateStorageTexture("h0k",e,i,i,a.Constants.TEXTUREFORMAT_RG),this._spectrumParameters=new a.StorageBuffer(this._engine,64,a.Constants.BUFFER_CREATIONFLAG_READWRITE),this._params=new a.UniformBuffer(this._engine),this._params.addUniform("Size",1),this._params.addUniform("LengthScale",1),this._params.addUniform("CutoffHigh",1),this._params.addUniform("CutoffLow",1),this._params.addUniform("GravityAcceleration",1),this._params.addUniform("Depth",1),this._phase1.setStorageTexture("WavesData",this._precomputedData),this._phase1.setStorageTexture("H0K",this._buffer),this._phase1.setTexture("Noise",s,!1),this._phase1.setStorageBuffer("spectrumParameters",this._spectrumParameters),this._phase1.setUniformBuffer("params",this._params),this._phase2=new a.ComputeShader("initialSpectrum2",this._engine,{computeSource:"[[group(0), binding(0)]] var H0 : texture_storage_2d<rgba32float, write>;\r\n\r\n[[block]] struct Params {\r\n    Size : u32;\r\n    LengthScale : f32;\r\n    CutoffHigh : f32;\r\n    CutoffLow : f32;\r\n    GravityAcceleration : f32;\r\n    Depth : f32;\r\n};\r\n\r\n[[group(0), binding(5)]] var<uniform> params : Params;\r\n\r\n[[group(0), binding(8)]] var H0K : texture_2d<f32>;\r\n\r\n[[stage(compute), workgroup_size(8,8,1)]]\r\nfn calculateConjugatedSpectrum([[builtin(global_invocation_id)]] id : vec3<u32>)\r\n{\r\n    let h0K = textureLoad(H0K, vec2<i32>(id.xy), 0).xy;\r\n\tlet h0MinusK = textureLoad(H0K, vec2<i32>(i32(params.Size - id.x) % i32(params.Size), i32(params.Size - id.y) % i32(params.Size)), 0);\r\n\r\n    textureStore(H0, vec2<i32>(id.xy), vec4<f32>(h0K.x, h0K.y, h0MinusK.x, -h0MinusK.y));\r\n}\r\n"},{bindingsMapping:{H0:{group:0,binding:0},params:{group:0,binding:5},H0K:{group:0,binding:8}},entryPoint:"calculateConjugatedSpectrum"}),this._phase2.setStorageTexture("H0",this._initialSpectrum),this._phase2.setUniformBuffer("params",this._params),this._phase2.setTexture("H0K",this._buffer,!1),this._rttDebug.setTexture(this._debugFirstIndex+0,"waves precompute",this._precomputedData),this._rttDebug.setTexture(this._debugFirstIndex+1,"H0K",this._buffer,1e3),this._rttDebug.setTexture(this._debugFirstIndex+2,"H0",this._initialSpectrum,1e3)}return Object.defineProperty(e.prototype,"initialSpectrum",{get:function(){return this._initialSpectrum},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"wavesData",{get:function(){return this._precomputedData},enumerable:!1,configurable:!0}),e.prototype.generate=function(e,t,r,a){this._params.updateInt("Size",this._textureSize),this._params.updateFloat("LengthScale",t),this._params.updateFloat("CutoffHigh",a),this._params.updateFloat("CutoffLow",r),e.setParametersToShader(this._params,this._spectrumParameters),this._params.update(),n.ComputeHelper.Dispatch(this._phase1,this._textureSize,this._textureSize,1),n.ComputeHelper.Dispatch(this._phase2,this._textureSize,this._textureSize,1)},e.prototype.dispose=function(){this._spectrumParameters.dispose(),this._params.dispose(),this._precomputedData.dispose(),this._buffer.dispose(),this._initialSpectrum.dispose(),this._phase1=null,this._phase2=null},e}()},7014:(e,t,r)=>{"use strict";r.r(t),r.d(t,{ComputeHelper:()=>n});var a=r(2264),n=function(){function e(){}return e.GetThreadGroupSizes=function(e,t){var r=new RegExp("workgroup_size\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)]]\\s*fn\\s+"+t+"\\s*\\(","g").exec(e);return r?new a.Vector3(parseInt(r[1]),parseInt(r[2]),parseInt(r[3])):new a.Vector3(1,1,1)},e.CreateStorageTexture=function(e,t,r,n,i,s,o,u,p,g){var m,f;void 0===i&&(i=a.Constants.TEXTUREFORMAT_RGBA),void 0===s&&(s=a.Constants.TEXTURETYPE_FLOAT),void 0===o&&(o=a.Constants.TEXTURE_NEAREST_SAMPLINGMODE),void 0===u&&(u=!1),void 0===p&&(p=a.Constants.TEXTURE_WRAP_ADDRESSMODE),void 0===g&&(g=null);var d=g?g.getSize():{width:0,height:0},c=d.width,h=d.height,l=g?null!==(m=g.getInternalTexture().type)&&void 0!==m?m:-1:-2,_=g?null!==(f=g.getInternalTexture().format)&&void 0!==f?f:-1:-2;return-1===l&&(l=a.Constants.TEXTURETYPE_UNSIGNED_BYTE),-1===_&&(_=a.Constants.TEXTUREFORMAT_RGBA),g&&c===r&&h===n&&s===l&&i===_||((g=new a.RawTexture(null,r,n,i,t,u,!1,o,s,a.Constants.TEXTURE_CREATIONFLAG_STORAGE)).name=e),g.wrapU=p,g.wrapV=p,g.updateSamplingMode(o),g},e.CopyTexture=function(t,r,n){var i,s,o=t.getInternalTexture().format===a.Constants.TEXTUREFORMAT_RG?2:4;if(!e._copyTexture4CS&&4===o||!e._copyTexture2CS&&2===o){var u=null!==(s=null===(i=t.getScene())||void 0===i?void 0:i.getEngine())&&void 0!==s?s:n,p=new a.ComputeShader("copyTexture"+o+"Compute",u,{computeSource:4===o?e._copyTexture4ComputeShader:e._copyTexture2ComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),g=new a.UniformBuffer(u);g.addUniform("width",1),g.addUniform("height",1),p.setUniformBuffer("params",g),4===o?(e._copyTexture4CS=p,e._copyTexture4Params=g):(e._copyTexture2CS=p,e._copyTexture2Params=g)}var m=4===o?e._copyTexture4CS:e._copyTexture2CS,f=4===o?e._copyTexture4Params:e._copyTexture2Params;m.setTexture("src",t,!1),m.setStorageTexture("dest",r);var d=t.getSize(),c=d.width,h=d.height;f.updateInt("width",c),f.updateInt("height",h),f.update(),e.Dispatch(m,c,h,1)},e.CopyBufferToTexture=function(t,r){if(!e._copyBufferTextureCS){var n=r.getScene().getEngine(),i=new a.ComputeShader("copyBufferTextureCompute",n,{computeSource:e._copyBufferTextureComputeShader},{bindingsMapping:{dest:{group:0,binding:0},src:{group:0,binding:1},params:{group:0,binding:2}}}),s=new a.UniformBuffer(n);s.addUniform("width",1),s.addUniform("height",1),i.setUniformBuffer("params",s),e._copyBufferTextureCS=i,e._copyBufferTextureParams=s}e._copyBufferTextureCS.setStorageBuffer("src",t),e._copyBufferTextureCS.setStorageTexture("dest",r);var o=r.getSize(),u=o.width,p=o.height;e._copyBufferTextureParams.updateInt("width",u),e._copyBufferTextureParams.updateInt("height",p),e._copyBufferTextureParams.update(),e.Dispatch(e._copyBufferTextureCS,u,p,1)},e.CopyTextureToBuffer=function(t,r){if(!e._copyTextureBufferCS){var n=t.getScene().getEngine(),i=new a.ComputeShader("copyTextureBufferCompute",n,{computeSource:e._copyTextureBufferComputeShader},{bindingsMapping:{src:{group:0,binding:0},dest:{group:0,binding:1},params:{group:0,binding:2}}}),s=new a.UniformBuffer(n);s.addUniform("width",1),s.addUniform("height",1),i.setUniformBuffer("params",s),e._copyTextureBufferCS=i,e._copyTextureBufferParams=s}e._copyTextureBufferCS.setTexture("src",t,!1),e._copyTextureBufferCS.setStorageBuffer("dest",r);var o=t.getSize(),u=o.width,p=o.height;e._copyTextureBufferParams.updateInt("width",u),e._copyTextureBufferParams.updateInt("height",p),e._copyTextureBufferParams.update(),e.Dispatch(e._copyTextureBufferCS,u,p,1)},e.ClearTexture=function(t,r){if(!e._clearTextureCS){var n=t.getScene().getEngine(),i=new a.ComputeShader("clearTextureCompute",n,{computeSource:e._clearTextureComputeShader},{bindingsMapping:{tbuf:{group:0,binding:0},params:{group:0,binding:1}}}),s=new a.UniformBuffer(n);s.addUniform("color",4),s.addUniform("width",1),s.addUniform("height",1),i.setUniformBuffer("params",s),e._clearTextureCS=i,e._clearTextureParams=s}e._clearTextureCS.setStorageTexture("tbuf",t);var o=t.getSize(),u=o.width,p=o.height;e._clearTextureParams.updateDirectColor4("color",r),e._clearTextureParams.updateInt("width",u),e._clearTextureParams.updateInt("height",p),e._clearTextureParams.update(),e.Dispatch(e._clearTextureCS,u,p,1)},e.Dispatch=function(t,r,a,n){var i;void 0===a&&(a=1),void 0===n&&(n=1),t.threadGroupSizes||(t.threadGroupSizes=e.GetThreadGroupSizes(t.shaderPath.computeSource,null!==(i=t.options.entryPoint)&&void 0!==i?i:"main"));var s=t.threadGroupSizes,o=Math.ceil(r/s.x),u=Math.ceil(a/s.y),p=Math.ceil(n/s.z);t.dispatch(o,u,p)},e._clearTextureComputeShader="\n        [[group(0), binding(0)]] var tbuf : texture_storage_2d<rgba32float, write>;\n\n        [[block]] struct Params {\n            color : vec4<f32>;\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(1)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            textureStore(tbuf, vec2<i32>(global_id.xy), params.color);\n        }\n    ",e._copyTexture4ComputeShader="\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba32float, write>;\n        [[group(0), binding(1)]] var src : texture_2d<f32>;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTexture2ComputeShader="\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rg32float, write>;\n        [[group(0), binding(1)]] var src : texture_2d<f32>;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyBufferTextureComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var dest : texture_storage_2d<rgba32float, write>;\n        [[group(0), binding(1)]] var<storage, read> src : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = vec4<f32>(src.elements[offset], src.elements[offset + 1u], src.elements[offset + 2u], src.elements[offset + 3u]);\n            textureStore(dest, vec2<i32>(global_id.xy), pix);\n        }\n    ",e._copyTextureBufferComputeShader="\n        [[block]] struct FloatArray {\n            elements : array<f32>;\n        };\n\n        [[group(0), binding(0)]] var src : texture_2d<f32>;\n        [[group(0), binding(1)]] var<storage, write> dest : FloatArray;\n\n        [[block]] struct Params {\n            width : u32;\n            height : u32;\n        };\n        [[group(0), binding(2)]] var<uniform> params : Params;\n\n        [[stage(compute), workgroup_size(8, 8, 1)]]\n        fn main([[builtin(global_invocation_id)]] global_id : vec3<u32>) {\n            if (global_id.x >= params.width || global_id.y >= params.height) {\n                return;\n            }\n            let offset : u32 = global_id.y * params.width * 4u + global_id.x * 4u;\n            let pix : vec4<f32> = textureLoad(src, vec2<i32>(global_id.xy), 0);\n            dest.elements[offset] = pix.r;\n            dest.elements[offset + 1u] = pix.g;\n            dest.elements[offset + 2u] = pix.b;\n            dest.elements[offset + 3u] = pix.a;\n        }\n    ",e}()}}]);
//# sourceMappingURL=494.babylonBundle.js.map